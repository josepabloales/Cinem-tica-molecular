{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Marco Te\u00f3rico","text":""},{"location":"#proyecto-final-del-curso-fisica-computacional-universidad-de-costa-rica-semestre-i-2024","title":"Proyecto final del curso F\u00edsica Computacional, Universidad de Costa Rica, Semestre I 2024.","text":"<p>Estudiantes: Keylor Rivera, Kevin Vega, Jos\u00e9 Pablo Alvarado, Mateo Heinz, Ana Laura V\u00edquez</p>"},{"location":"#cinematica","title":"Cinem\u00e1tica","text":"<p>La cinem\u00e1tica es la rama de la mec\u00e1nica que estudia el movimiento de los cuerpos. Se enfoca en describir c\u00f3mo se mueven los objetos en el espacio y el tiempo, utilizando conceptos como la posici\u00f3n, la velocidad y la aceleraci\u00f3n.</p> <p>Cuando el movimiento de una particula es con velocidad constante, es decir cuando la aceleraci\u00f3n es cero, este movimiento se denomina movimiento rectil\u00edneo uniforme y la ecuaci\u00f3n que describe la posici\u00f3n de una part\u00edcula esta descrita por:</p> \\[  x = x_0 + v_0t  \\] <p>Donde x es la posici\u00f3n, x_0 la posici\u00f3n inicial, v_0 la velocidad inicial y t el tiempo.</p> <p>El momento p, esta definido como: $$  p = mv $$ Donde m es la masa de la particula.</p> <p>La energ\u00eda cin\u00e9tica K, de la part\u00edcula es descrita por:  $$ K = \\frac{1}{2}mv^2 $$</p>"},{"location":"#colisiones-elasticas-en-una-dimension","title":"Colisiones el\u00e1sticas en una dimensi\u00f3n","text":"<p>Cuando 2 part\u00edculas A y B chocan, y la fuerza entre los dos es conservativa, se dice que el choque es el\u00e1stico. En este tipo de choques la energ\u00eda cin\u00e9tica del sistema es la misma antes y despu\u00e9s del choque, por lo que el momento y la energ\u00eda cin\u00e9tica de cada part\u00edcula se conserva:</p> \\[ m_Av_{A1} + m_Bv_{B1} = m_Av_{A2}+ m_Bv_{B2} \\] \\[ \\frac{1}{2}m_Av_{A1}^2 + \\frac{1}{2}m_Bv_{B1}^2 = \\frac{1}{2}m_Av_{A2}^2 + \\frac{1}{2}m_Bv_{B2}^2 \\] <p>Combinando estas dos ecuaciones se obtienen las velocidades v_A2 y v_B2:</p> \\[ v_{A2} = \\frac{v_{A1}(m_A - m_B) + 2m_Bv_{B1}}{m_A + m_B} \\] \\[ v_{B2} = \\frac{v_{B1}(m_B - m_A) + 2m_Av_{A1}}{m_A + m_B} \\]"},{"location":"#colisiones-elasticas-en-dos-dimensiones","title":"Colisiones el\u00e1sticas en dos dimensiones","text":"<p>Si se considera la colisi\u00f3n el\u00e1stica entre dos discos s\u00f3lidos, hay que considerar 2 componentes para la velocidad de cada disco. Ahora si proyectamos los componentes de velocidad de los discos sobre los vectores perpendiculares y tangentes a la superficie de colisi\u00f3n, podemos utilizar la componente de velocidad perpendicular y tratarla como en una colisi\u00f3n de una dimensi\u00f3n.</p> <p>Para calcular las velocidades de dos entre dos discos s\u00f3lidos tras una colisi\u00f3n el\u00e1stica, sin el uso de trigonometr\u00eda, se puede aplicar lo siguiente. B\u00e1sicamente se hace a partir de un cambio de coordenadas, los cuales est\u00e1n determinados por los vectores normales y tangenciales a la superficie de choque de los discos. Para el eje tangencial no hay ninguna fuerza involucrada, por lo que su rapidez en ese eje se mantiene constante. Para el eje normal, donde est\u00e1 la fuerza del choque, tan solo se analiza como una colisi\u00f3n en una dimensi\u00f3n, lo que facilita much\u00edsimo el c\u00e1lculo. Este es el proceso, inicialmente hay que calcular el vector normal a la colisi\u00f3n, este ser\u00e1 dado por la distancia entre los centros de cada disco, si tenemos el disco A y el disco B, y sus centros C est\u00e1n dados en coordenadas de la siguiente manera:</p> \\[ C_A = (x_a,y_a)  \\] \\[ C_B = (x_b,y_b) \\] <p>Entonces, el vector normal ser\u00e1:</p> \\[ \\vec{n} = C_A - C_B = (x_a - x_b,y_a - y_b) = (n_x,n_y) \\] <p>Y de forma unitaria ser\u00eda: </p> \\[ \\hat{n} = \\frac{\\vec{n}}{||\\vec{n}||} = \\frac{(n_x,n_y)}{\\sqrt{n_x^2 + n_y^2}} \\] <p>Ahora es necesario el vector tangente a las superficies, el cual es simplemente una rotaci\u00f3n de 90 grados del vector normal, o que b\u00e1sicamente la primera componente del vector tangente es el negativo de la segunda componente del vector normal, y la segunda componente del tangente es igual a la primera del normal. </p> \\[ \\hat{t} = \\frac{\\vec{t}}{||\\vec{n}||} = \\frac{(-n_y,n_x)}{\\sqrt{n_x^2 + n_y^2}} \\] <p>Ahora se establecen los vectores de velocidad con respecto al eje de coordenadas original.</p> \\[ \\vec{v}_{A1} = (v_{ax},v_{ay}) \\] \\[ \\vec{v}_{B1}= (v_{bx},v_{by}) \\] <p>A continuaci\u00f3n se deben adaptar las componentes de estos vectores en las componentes del nuevo sistema de coordenadas a partir de proyecciones sobre los ejes normales y tangentes, o productos punto con estos. Al crear un sistema de coordenadas de esta forma, se obtiene que la velocidad relacionada al eje normal en ambos discos se tratar\u00e1 como si de una colisi\u00f3n unidimensional se tratase, mientras que para la velocidad en el eje tangente, se mantendr\u00e1 constante pues no hay fuerza actuando en esa direcci\u00f3n. Sea el sub\u00edndice \\(n\\) con respecto a la normal y \\(t\\) con respecto a la tangente. Las componentes de las velocidades de \\(A\\) y \\(B\\) antes de la colisi\u00f3n son:</p> \\[ v_{An1} = \\vec{v}_A \\cdot \\hat{n} \\] \\[ v_{At1} = \\vec{v}_A \\cdot \\hat{t} = v_{At2} (constante) \\] \\[ v_{Bn1} = \\vec{v}_B \\cdot \\hat{n} \\] \\[ v_{Bt1} = \\vec{v}_B \\cdot \\hat{t} = v_{Bt2} (constante) \\] <p>Tras el choque, la velocidad tangencial ser\u00e1 exactamente la misma, ya que no hay fuerza que altere su trayectoria. En el caso de la componente normal, la velocidad tras el choque est\u00e1 dada por las siguientes expresiones:</p> \\[ v_{An2} = \\frac{v_{An1}(m_A - m_B) + 2m_Bv_{Bn1}}{m_A + m_B} \\] \\[ v_{Bn2} = \\frac{v_{Bn1}(m_B - m_A) + 2m_Av_{An1}}{m_A + m_B} \\] <p>Estas son las componentes normales del vector velocidad tras la colisi\u00f3n de ambos cuerpos, para hacerlos de nuevo como vectores se toma multiplican por el vector correspondiente que les da su direcci\u00f3n:</p> \\[ \\vec{v}_{An2} = {v}_{An2} \\hat{n} \\] \\[ \\vec{v}_{At2} = {v}_{At2} \\hat{t} \\] \\[ \\vec{v}_{Bn2} = {v}_{Bn2} \\hat{n} \\] \\[ \\vec{v}_{Bt2} = {v}_{Bt2} \\hat{t} \\] <p>Finalmente, la velocidad tras la colisi\u00f3n en el sistema de coordenadas original ser\u00e1 igual a la suma vectorial de la parte normal m\u00e1s la parte tangente:</p> \\[ \\vec{v}_{A2} = \\vec{v}_{An2} + \\vec{v}_{At2} \\] \\[ \\vec{v}_{B2} = \\vec{v}_{Bn2} + \\vec{v}_{Bt2} \\]"},{"location":"#bibliografia","title":"Bibliograf\u00eda","text":"<p>Resnick R, Halliday D, Krane KS. F\u00edsica Volumen 1. Continental; 2001.</p>"},{"location":"reference/","title":"Documentaci\u00f3n","text":""},{"location":"reference/#el-programa-simula-4-discos-solidos-de-radio-r-que-se-mueven-sin-friccion-ni-momento-angular-dentro-de-una-caja-de-longitud-unitaria","title":"El programa simula 4 discos s\u00f3lidos de radio r que se mueven sin fricci\u00f3n ni momento angular dentro de una caja de longitud unitaria.","text":""},{"location":"reference/#discos.proyecto.Particula","title":"<code>Particula</code>","text":"Source code in <code>discos/proyecto.py</code> <pre><code>class Particula:\n    def __init__(self, pos, rad, masa, rapidez, ang, color):\n        '''Constructor que inicializa un disco con una posici\u00f3n, radio, masa, rapidez, angulo y color.\n           Adem\u00e1s asigana una variable de velocidad v, definida como:\n\n           $$\n           v = (rapidez * cos(ang), rapidez * sin(ang))\n           $$\n\n           Donde ang es el \u00e1ngulo en radianes.\n\n        Args:\n            pos (list): La posici\u00f3n inicial del disco en [x, y]\n            rad (float): El radio del disco\n            masa (float): La masa de del disco\n            rapidez (float): La rapidez del disco\n            ang (float): El \u00e1ngulo de la velocidad del disco en radianes\n            color (str): El color del disco para la visualizaci\u00f3n\n\n        '''\n        self.pos = pos  \n        self.rad = rad\n        self.masa = masa\n        self.ang = ang\n        self.rapidez = rapidez\n        self.v = [rapidez * np.cos(ang), rapidez * np.sin(ang)]\n        self.color = color\n\n    def mover(self, dt):\n        '''Esta funci\u00f3n es un m\u00e9todo, actualiza la posici\u00f3n de los discos siguiendo la ecuaci\u00f3n\n           de posici\u00f3n del movimiento rectil\u00edneo uniforme:\n\n           $$\n           x = x_{0} + v_{0}t\n           $$\n\n           Donde x es la posici\u00f3n (puede tomar en el eje x y en el eje y), x{0} la posici\u00f3n inicial y t el tiempo.\n\n        Args:\n            dt (float): El intervalo de tiempo durante el cual se actualiza la posici\u00f3n\n\n        '''\n        self.pos[0] += self.v[0] * dt\n        self.pos[1] += self.v[1] * dt\n\n    def display(self, ax):\n        '''Funci\u00f3n que dibuja el disco con la flecha que representa su velocidad, en el gr\u00e1fico.\n           Mantiene una longitud fija para la flecha y da la direcci\u00f3n de la flecha seg\u00fan el\n           \u00e1ngulo de la velocidad.\n\n        Args:\n            ax (matplotlib.axes.Axes): El objeto de los ejes en los que se dibuja los discos\n\n        '''\n        circulo = plt.Circle(self.pos, self.rad, edgecolor='k', facecolor=self.color)\n        ax.add_patch(circulo)\n        # Longitud fija para la flecha\n        longitud_flecha = 0.1\n        # Direcci\u00f3n de la flecha seg\u00fan el \u00e1ngulo de la velocidad\n        direccion = np.arctan2(self.v[1], self.v[0])\n        final_pos = [self.pos[0] + longitud_flecha * np.cos(direccion), self.pos[1] + longitud_flecha * np.sin(direccion)]\n        ax.quiver(self.pos[0], self.pos[1], final_pos[0] - self.pos[0], final_pos[1] - self.pos[1], angles='xy', scale_units='xy', scale=1, color='k')\n\n    def tiempo_a_pared(self, size):\n        '''Esta funci\u00f3n calcula el m\u00ednimo tiempo de colisi\u00f3n entre un disco y las paredes de la caja.\n           Para esto calcula los tiempos de colision con cada pared y toma el menor de estos tiempos.\n\n        Args:\n            size (list): Tama\u00f1o de la caja en [x, y]\n\n        Returns:\n            float (float): El tiempo hasta la colisi\u00f3n con la pared m\u00e1s cercana\n\n        '''\n        tx_derecha = (size[0] - self.rad - self.pos[0]) / self.v[0] if self.v[0] &gt; 0 else float('inf')\n        tx_izquierda = (self.rad - self.pos[0]) / self.v[0] if self.v[0] &lt; 0 else float('inf')\n        ty_arriba = (size[1] - self.rad - self.pos[1]) / self.v[1] if self.v[1] &gt; 0 else float('inf')\n        ty_abajo = (self.rad - self.pos[1]) / self.v[1] if self.v[1] &lt; 0 else float('inf')\n        return min(tx_derecha, tx_izquierda, ty_arriba, ty_abajo)\n\n    @staticmethod\n    def tiempo_a_pares(part_a, part_b):\n        '''Es una funci\u00f3n que se utiliza para declarar un m\u00e9todo est\u00e1tico dentro de una clase.\n           Calcula el tiempo hasta la colisi\u00f3n entre dos discos.\n           En este caso indica que pair_time es un m\u00e9todo est\u00e1tico,\n           lo que significa que no requiere una instancia de la clase para ser llamado.\n           Sabemos que una colisi\u00f3n ocurre cuando la distancia del centro de cada part\u00edcula\n           a la otra es la suma de ambos radios R:\n\n           $$\n           R = r_{a} + r_{b}\n           $$\n\n           Ahora para encontrar la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n hacemos lo siguiente:\n           Como estudiamos esto con movimiento relativo, analizamos que este R como la suma de los radios, se cumple cuando:\n\n           $$\n           r(0) + vt \n           $$\n\n           Entonces ahora podemos partir de:\n\n           $$\n\t   \\|r(0) + v t \\|^2 =  R^2 \n           $$\n\n           Por lo que:\n\n           $$\n           (r(0) + v t)^2 = R^2\n           $$\n\n           $$\n           \\|r(0)\\|^2 + 2 r(0) v t + \\|v\\|^2 t^2 = R^2\n           $$\n\n           $$\n           \\| v \\|^2 t^2 + 2 r(0) v t + \\| r(0) \\|^2 - R^2 = 0\n\t   $$\n\n           As\u00ed, la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n es:\n\n           $$\n           a t^2 + b t + c = 0\n           $$\n\n           donde \n\n           $$\n           a = \\|v\\|^2 \n           $$\n\n           $$\n           b = 2 (v * r(0))\n           $$\n\n           $$\n           c = \\| r(0) \\|^2 - R^2\n           $$\n\n           Ahora, aplicando esta f\u00edsica al c\u00f3digo tenemos:\n\n           det es el discriminante de la ecuaci\u00f3n cuadr\u00e1tica que se resolver\u00e1 para encontrar los tiempos de colisi\u00f3n.\n           Este valor determina si hay soluciones reales (y por lo tanto colisiones):\n\n           $$\n           det = (2 * b)^2 - 4 * \\|v\\|^2  * (\\|r(0)\\|^2  - R^2)\n           $$\n\n           Verificamos si hay soluciones reales (o colisi\u00f3n posible) y si las part\u00edculas se est\u00e1n acercando una a la otra (b &lt; 0.0).\n           sqrt_det calcula la ra\u00edz cuadrada del discriminante. Esto para poder resolver la ecuaci\u00f3n cuadr\u00e1tica por f\u00f3rmula general.\n           del_t1 y del_t2 son las dos soluciones de la ecuaci\u00f3n cuadr\u00e1tica que representan los tiempos en los que las part\u00edculas podr\u00edan colisionar.\n\n           Luego se selecciona el primer momento futuro en el que ocurre la colisi\u00f3n (el menor tiempo no negativo).\n           Si ambos tiempos son negativos o si no hay soluciones reales, del_t se mantiene como infinito (float('inf')),\n           indicando que no hay colisi\u00f3n en el futuro.\n\n        Args:\n            part_a (Particula): El primer disco\n            part_b (Particula): El segundo disco\n\n        Returns:\n            float (float): El tiempo hasta la colisi\u00f3n entre dos discos, o infinito si no colisionan\n\n        '''\n        del_x = [part_b.pos[0] - part_a.pos[0], part_b.pos[1] - part_a.pos[1]]\n        del_x_sq = del_x[0]**2 + del_x[1]**2\n        del_v = [part_b.v[0] - part_a.v[0], part_b.v[1] - part_a.v[1]]\n        del_v_sq = del_v[0]**2 + del_v[1]**2\n        b = del_v[0] * del_x[0] + del_v[1] * del_x[1]\n        sum_rad = part_a.rad + part_b.rad\n        det = (2 * b)**2 - 4 * del_v_sq * (del_x_sq - sum_rad**2)\n\n        if det &gt;= 0.0 and b &lt; 0.0:\n            sqrt_det = math.sqrt(det)\n            del_t1 = ((-2 * b) + sqrt_det) / (2 * del_v_sq)\n            del_t2 = ((-2 * b) - sqrt_det) / (2 * del_v_sq)\n\n            # Seleccionar el tiempo m\u00ednimo no negativo\n            del_t = float('inf')\n            if del_t1 &gt;= 0:\n                del_t = del_t1\n            if del_t2 &gt;= 0 and del_t2 &lt; del_t:\n                del_t = del_t2\n        else:\n            del_t = float('inf')\n        return del_t\n</code></pre>"},{"location":"reference/#discos.proyecto.Particula.__init__","title":"<code>__init__(pos, rad, masa, rapidez, ang, color)</code>","text":"<p>Constructor que inicializa un disco con una posici\u00f3n, radio, masa, rapidez, angulo y color.    Adem\u00e1s asigana una variable de velocidad v, definida como:</p> <p>$$    v = (rapidez * cos(ang), rapidez * sin(ang))    $$</p> <p>Donde ang es el \u00e1ngulo en radianes.</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>list</code> <p>La posici\u00f3n inicial del disco en [x, y]</p> required <code>rad</code> <code>float</code> <p>El radio del disco</p> required <code>masa</code> <code>float</code> <p>La masa de del disco</p> required <code>rapidez</code> <code>float</code> <p>La rapidez del disco</p> required <code>ang</code> <code>float</code> <p>El \u00e1ngulo de la velocidad del disco en radianes</p> required <code>color</code> <code>str</code> <p>El color del disco para la visualizaci\u00f3n</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def __init__(self, pos, rad, masa, rapidez, ang, color):\n    '''Constructor que inicializa un disco con una posici\u00f3n, radio, masa, rapidez, angulo y color.\n       Adem\u00e1s asigana una variable de velocidad v, definida como:\n\n       $$\n       v = (rapidez * cos(ang), rapidez * sin(ang))\n       $$\n\n       Donde ang es el \u00e1ngulo en radianes.\n\n    Args:\n        pos (list): La posici\u00f3n inicial del disco en [x, y]\n        rad (float): El radio del disco\n        masa (float): La masa de del disco\n        rapidez (float): La rapidez del disco\n        ang (float): El \u00e1ngulo de la velocidad del disco en radianes\n        color (str): El color del disco para la visualizaci\u00f3n\n\n    '''\n    self.pos = pos  \n    self.rad = rad\n    self.masa = masa\n    self.ang = ang\n    self.rapidez = rapidez\n    self.v = [rapidez * np.cos(ang), rapidez * np.sin(ang)]\n    self.color = color\n</code></pre>"},{"location":"reference/#discos.proyecto.Particula.display","title":"<code>display(ax)</code>","text":"<p>Funci\u00f3n que dibuja el disco con la flecha que representa su velocidad, en el gr\u00e1fico.    Mantiene una longitud fija para la flecha y da la direcci\u00f3n de la flecha seg\u00fan el    \u00e1ngulo de la velocidad.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>El objeto de los ejes en los que se dibuja los discos</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def display(self, ax):\n    '''Funci\u00f3n que dibuja el disco con la flecha que representa su velocidad, en el gr\u00e1fico.\n       Mantiene una longitud fija para la flecha y da la direcci\u00f3n de la flecha seg\u00fan el\n       \u00e1ngulo de la velocidad.\n\n    Args:\n        ax (matplotlib.axes.Axes): El objeto de los ejes en los que se dibuja los discos\n\n    '''\n    circulo = plt.Circle(self.pos, self.rad, edgecolor='k', facecolor=self.color)\n    ax.add_patch(circulo)\n    # Longitud fija para la flecha\n    longitud_flecha = 0.1\n    # Direcci\u00f3n de la flecha seg\u00fan el \u00e1ngulo de la velocidad\n    direccion = np.arctan2(self.v[1], self.v[0])\n    final_pos = [self.pos[0] + longitud_flecha * np.cos(direccion), self.pos[1] + longitud_flecha * np.sin(direccion)]\n    ax.quiver(self.pos[0], self.pos[1], final_pos[0] - self.pos[0], final_pos[1] - self.pos[1], angles='xy', scale_units='xy', scale=1, color='k')\n</code></pre>"},{"location":"reference/#discos.proyecto.Particula.mover","title":"<code>mover(dt)</code>","text":"<p>Esta funci\u00f3n es un m\u00e9todo, actualiza la posici\u00f3n de los discos siguiendo la ecuaci\u00f3n    de posici\u00f3n del movimiento rectil\u00edneo uniforme:</p> <p>$$    x = x_{0} + v_{0}t    $$</p> <p>Donde x es la posici\u00f3n (puede tomar en el eje x y en el eje y), x{0} la posici\u00f3n inicial y t el tiempo.</p> <p>Parameters:</p> Name Type Description Default <code>dt</code> <code>float</code> <p>El intervalo de tiempo durante el cual se actualiza la posici\u00f3n</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def mover(self, dt):\n    '''Esta funci\u00f3n es un m\u00e9todo, actualiza la posici\u00f3n de los discos siguiendo la ecuaci\u00f3n\n       de posici\u00f3n del movimiento rectil\u00edneo uniforme:\n\n       $$\n       x = x_{0} + v_{0}t\n       $$\n\n       Donde x es la posici\u00f3n (puede tomar en el eje x y en el eje y), x{0} la posici\u00f3n inicial y t el tiempo.\n\n    Args:\n        dt (float): El intervalo de tiempo durante el cual se actualiza la posici\u00f3n\n\n    '''\n    self.pos[0] += self.v[0] * dt\n    self.pos[1] += self.v[1] * dt\n</code></pre>"},{"location":"reference/#discos.proyecto.Particula.tiempo_a_pared","title":"<code>tiempo_a_pared(size)</code>","text":"<p>Esta funci\u00f3n calcula el m\u00ednimo tiempo de colisi\u00f3n entre un disco y las paredes de la caja.    Para esto calcula los tiempos de colision con cada pared y toma el menor de estos tiempos.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>list</code> <p>Tama\u00f1o de la caja en [x, y]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>El tiempo hasta la colisi\u00f3n con la pared m\u00e1s cercana</p> Source code in <code>discos/proyecto.py</code> <pre><code>def tiempo_a_pared(self, size):\n    '''Esta funci\u00f3n calcula el m\u00ednimo tiempo de colisi\u00f3n entre un disco y las paredes de la caja.\n       Para esto calcula los tiempos de colision con cada pared y toma el menor de estos tiempos.\n\n    Args:\n        size (list): Tama\u00f1o de la caja en [x, y]\n\n    Returns:\n        float (float): El tiempo hasta la colisi\u00f3n con la pared m\u00e1s cercana\n\n    '''\n    tx_derecha = (size[0] - self.rad - self.pos[0]) / self.v[0] if self.v[0] &gt; 0 else float('inf')\n    tx_izquierda = (self.rad - self.pos[0]) / self.v[0] if self.v[0] &lt; 0 else float('inf')\n    ty_arriba = (size[1] - self.rad - self.pos[1]) / self.v[1] if self.v[1] &gt; 0 else float('inf')\n    ty_abajo = (self.rad - self.pos[1]) / self.v[1] if self.v[1] &lt; 0 else float('inf')\n    return min(tx_derecha, tx_izquierda, ty_arriba, ty_abajo)\n</code></pre>"},{"location":"reference/#discos.proyecto.Particula.tiempo_a_pares","title":"<code>tiempo_a_pares(part_a, part_b)</code>  <code>staticmethod</code>","text":"<p>Es una funci\u00f3n que se utiliza para declarar un m\u00e9todo est\u00e1tico dentro de una clase.    Calcula el tiempo hasta la colisi\u00f3n entre dos discos.    En este caso indica que pair_time es un m\u00e9todo est\u00e1tico,    lo que significa que no requiere una instancia de la clase para ser llamado.    Sabemos que una colisi\u00f3n ocurre cuando la distancia del centro de cada part\u00edcula    a la otra es la suma de ambos radios R:</p> <p>$$    R = r_{a} + r_{b}    $$</p> <p>Ahora para encontrar la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n hacemos lo siguiente:    Como estudiamos esto con movimiento relativo, analizamos que este R como la suma de los radios, se cumple cuando:</p> <p>$$    r(0) + vt     $$</p> <p>Entonces ahora podemos partir de:</p> <p>$$    |r(0) + v t |^2 =  R^2     $$</p> <p>Por lo que:</p> <p>$$    (r(0) + v t)^2 = R^2    $$</p> <p>$$    |r(0)|^2 + 2 r(0) v t + |v|^2 t^2 = R^2    $$</p> <p>$$    | v |^2 t^2 + 2 r(0) v t + | r(0) |^2 - R^2 = 0    $$</p> <p>As\u00ed, la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n es:</p> <p>$$    a t^2 + b t + c = 0    $$</p> <p>donde </p> <p>$$    a = |v|^2     $$</p> <p>$$    b = 2 (v * r(0))    $$</p> <p>$$    c = | r(0) |^2 - R^2    $$</p> <p>Ahora, aplicando esta f\u00edsica al c\u00f3digo tenemos:</p> <p>det es el discriminante de la ecuaci\u00f3n cuadr\u00e1tica que se resolver\u00e1 para encontrar los tiempos de colisi\u00f3n.    Este valor determina si hay soluciones reales (y por lo tanto colisiones):</p> <p>$$    det = (2 * b)^2 - 4 * |v|^2  * (|r(0)|^2  - R^2)    $$</p> <p>Verificamos si hay soluciones reales (o colisi\u00f3n posible) y si las part\u00edculas se est\u00e1n acercando una a la otra (b &lt; 0.0).    sqrt_det calcula la ra\u00edz cuadrada del discriminante. Esto para poder resolver la ecuaci\u00f3n cuadr\u00e1tica por f\u00f3rmula general.    del_t1 y del_t2 son las dos soluciones de la ecuaci\u00f3n cuadr\u00e1tica que representan los tiempos en los que las part\u00edculas podr\u00edan colisionar.</p> <p>Luego se selecciona el primer momento futuro en el que ocurre la colisi\u00f3n (el menor tiempo no negativo).    Si ambos tiempos son negativos o si no hay soluciones reales, del_t se mantiene como infinito (float('inf')),    indicando que no hay colisi\u00f3n en el futuro.</p> <p>Parameters:</p> Name Type Description Default <code>part_a</code> <code>Particula</code> <p>El primer disco</p> required <code>part_b</code> <code>Particula</code> <p>El segundo disco</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>El tiempo hasta la colisi\u00f3n entre dos discos, o infinito si no colisionan</p> Source code in <code>discos/proyecto.py</code> <pre><code>    @staticmethod\n    def tiempo_a_pares(part_a, part_b):\n        '''Es una funci\u00f3n que se utiliza para declarar un m\u00e9todo est\u00e1tico dentro de una clase.\n           Calcula el tiempo hasta la colisi\u00f3n entre dos discos.\n           En este caso indica que pair_time es un m\u00e9todo est\u00e1tico,\n           lo que significa que no requiere una instancia de la clase para ser llamado.\n           Sabemos que una colisi\u00f3n ocurre cuando la distancia del centro de cada part\u00edcula\n           a la otra es la suma de ambos radios R:\n\n           $$\n           R = r_{a} + r_{b}\n           $$\n\n           Ahora para encontrar la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n hacemos lo siguiente:\n           Como estudiamos esto con movimiento relativo, analizamos que este R como la suma de los radios, se cumple cuando:\n\n           $$\n           r(0) + vt \n           $$\n\n           Entonces ahora podemos partir de:\n\n           $$\n\t   \\|r(0) + v t \\|^2 =  R^2 \n           $$\n\n           Por lo que:\n\n           $$\n           (r(0) + v t)^2 = R^2\n           $$\n\n           $$\n           \\|r(0)\\|^2 + 2 r(0) v t + \\|v\\|^2 t^2 = R^2\n           $$\n\n           $$\n           \\| v \\|^2 t^2 + 2 r(0) v t + \\| r(0) \\|^2 - R^2 = 0\n\t   $$\n\n           As\u00ed, la ecuaci\u00f3n cuadr\u00e1tica que determina el tiempo de colisi\u00f3n es:\n\n           $$\n           a t^2 + b t + c = 0\n           $$\n\n           donde \n\n           $$\n           a = \\|v\\|^2 \n           $$\n\n           $$\n           b = 2 (v * r(0))\n           $$\n\n           $$\n           c = \\| r(0) \\|^2 - R^2\n           $$\n\n           Ahora, aplicando esta f\u00edsica al c\u00f3digo tenemos:\n\n           det es el discriminante de la ecuaci\u00f3n cuadr\u00e1tica que se resolver\u00e1 para encontrar los tiempos de colisi\u00f3n.\n           Este valor determina si hay soluciones reales (y por lo tanto colisiones):\n\n           $$\n           det = (2 * b)^2 - 4 * \\|v\\|^2  * (\\|r(0)\\|^2  - R^2)\n           $$\n\n           Verificamos si hay soluciones reales (o colisi\u00f3n posible) y si las part\u00edculas se est\u00e1n acercando una a la otra (b &lt; 0.0).\n           sqrt_det calcula la ra\u00edz cuadrada del discriminante. Esto para poder resolver la ecuaci\u00f3n cuadr\u00e1tica por f\u00f3rmula general.\n           del_t1 y del_t2 son las dos soluciones de la ecuaci\u00f3n cuadr\u00e1tica que representan los tiempos en los que las part\u00edculas podr\u00edan colisionar.\n\n           Luego se selecciona el primer momento futuro en el que ocurre la colisi\u00f3n (el menor tiempo no negativo).\n           Si ambos tiempos son negativos o si no hay soluciones reales, del_t se mantiene como infinito (float('inf')),\n           indicando que no hay colisi\u00f3n en el futuro.\n\n        Args:\n            part_a (Particula): El primer disco\n            part_b (Particula): El segundo disco\n\n        Returns:\n            float (float): El tiempo hasta la colisi\u00f3n entre dos discos, o infinito si no colisionan\n\n        '''\n        del_x = [part_b.pos[0] - part_a.pos[0], part_b.pos[1] - part_a.pos[1]]\n        del_x_sq = del_x[0]**2 + del_x[1]**2\n        del_v = [part_b.v[0] - part_a.v[0], part_b.v[1] - part_a.v[1]]\n        del_v_sq = del_v[0]**2 + del_v[1]**2\n        b = del_v[0] * del_x[0] + del_v[1] * del_x[1]\n        sum_rad = part_a.rad + part_b.rad\n        det = (2 * b)**2 - 4 * del_v_sq * (del_x_sq - sum_rad**2)\n\n        if det &gt;= 0.0 and b &lt; 0.0:\n            sqrt_det = math.sqrt(det)\n            del_t1 = ((-2 * b) + sqrt_det) / (2 * del_v_sq)\n            del_t2 = ((-2 * b) - sqrt_det) / (2 * del_v_sq)\n\n            # Seleccionar el tiempo m\u00ednimo no negativo\n            del_t = float('inf')\n            if del_t1 &gt;= 0:\n                del_t = del_t1\n            if del_t2 &gt;= 0 and del_t2 &lt; del_t:\n                del_t = del_t2\n        else:\n            del_t = float('inf')\n        return del_t\n</code></pre>"},{"location":"reference/#discos.proyecto.actualizar","title":"<code>actualizar(frame, particulas, size, ax, posiciones_x, dt)</code>","text":"<p>Esta funci\u00f3n va creando y actualizando los frames para hacer evolucionar la simulaci\u00f3n en el tiempo. Primero lmpia el gr\u00e1fico, luego determina el tiempo m\u00ednimo hasta el proximo evento. Desp\u00faes mueve las part\u00edculas por el tiempo m\u00ednimo o dt, el que sea menor. </p> <p>Luego verifica y maneja las colisiones con las paredes. Si el tiempo m\u00ednimo es menor que el dt, entonces se da una colisi\u00f3n entre el disco y una pared. Si no es as\u00ed, entonces el frame continua para que la simulaci\u00f3n sea continua. Llama a la funci\u00f3n rebotar_pared si hay un choque con una pared.</p> <p>Desp\u00faes verifica y maneja las colisiones entre discos y captura las posiciones en x de los discos. Si hay colisi\u00f3n entre discos entonces se llama a la funci\u00f3n choque_elastico. Por \u00faltimo, dibuja los discos en la gr\u00e1fica.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>int</code> <p>el n\u00famero de frame</p> required <code>particulas</code> <code>list</code> <p>lista con los atributos de cada disco</p> required <code>size</code> <code>tuple</code> <p>el tama\u00f1o de la caja en x y y</p> required <code>ax</code> <code>Axes</code> <p>El objeto de los ejes en los que se dibuja los discos</p> required <code>posiciones_x</code> <code>list</code> <p>las posisciones en x de cada disco</p> required <code>dt</code> <code>float</code> <p>diferencial de tiempo, es la velocidad de evoluci\u00f3n de la simulaci\u00f3n</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def actualizar(frame, particulas, size, ax, posiciones_x,dt):\n    '''Esta funci\u00f3n va creando y actualizando los frames para hacer evolucionar la simulaci\u00f3n en el tiempo.\n       Primero lmpia el gr\u00e1fico, luego determina el tiempo m\u00ednimo hasta el proximo evento.\n       Desp\u00faes mueve las part\u00edculas por el tiempo m\u00ednimo o dt, el que sea menor. \n\n       Luego verifica y maneja las colisiones con las paredes. Si el tiempo m\u00ednimo es menor que el dt, entonces se\n       da una colisi\u00f3n entre el disco y una pared. Si no es as\u00ed, entonces el frame continua para que la simulaci\u00f3n\n       sea continua. Llama a la funci\u00f3n rebotar_pared si hay un choque con una pared.\n\n       Desp\u00faes verifica y maneja las colisiones entre discos y captura las posiciones en x de los discos.\n       Si hay colisi\u00f3n entre discos entonces se llama a la funci\u00f3n choque_elastico.\n       Por \u00faltimo, dibuja los discos en la gr\u00e1fica.\n\n       Args:\n           frame (int): el n\u00famero de frame\n           particulas (list): lista con los atributos de cada disco\n           size (tuple): el tama\u00f1o de la caja en x y y\n           ax (matplotlib.axes.Axes): El objeto de los ejes en los que se dibuja los discos\n           posiciones_x (list): las posisciones en x de cada disco\n           dt (float): diferencial de tiempo, es la velocidad de evoluci\u00f3n de la simulaci\u00f3n\n\n    '''\n    # Limpiar el gr\u00e1fico\n    ax.clear()\n    ax.set_xlim(0, size[0])\n    ax.set_ylim(0, size[1])\n\n    # Determinar el tiempo m\u00ednimo hasta el pr\u00f3ximo evento\n    tiempos_pared = [p.tiempo_a_pared(size) for p in particulas]\n    tiempos_pareja = [Particula.tiempo_a_pares(particulas[i], particulas[j]) for i in range(len(particulas)) for j in range(i+1, len(particulas))]\n    all_tiempos = tiempos_pared + tiempos_pareja\n    all_tiempos.sort()\n    min_tiempo = next(t for t in all_tiempos if t &gt; 1e-14 )  # Umbral de tiempo m\u00ednimo\n\n    tiempo_mover= min(min_tiempo, dt)\n    # Mover las part\u00edculas\n\n    for p in particulas:\n        p.mover(tiempo_mover+1e-15)\n    if min_tiempo &lt;= dt:\n        # Verificar colisiones con las paredes\n        for p in particulas:\n            rebotar_pared(p, size)\n\n        # Verificar colisiones entre part\u00edculas\n        for i in range(len(particulas)):\n            for j in range(i+1, len(particulas)):\n                choque_elastico(particulas[i], particulas[j])\n\n    # Capturar las posiciones en x de las part\u00edculas\n    posiciones_x.extend([p.pos[0] for p in particulas])\n\n    # Dibujar las part\u00edculas\n    for p in particulas:\n        p.display(ax)\n</code></pre>"},{"location":"reference/#discos.proyecto.choque_elastico","title":"<code>choque_elastico(part1, part2)</code>","text":"<p>Esta funci\u00f3n determina las nuevas velocidades de los discos A y B, si dos de ellos chocan entre s\u00ed. Se tiene la distancia d entre los discos: C_A - C_B, y esta es menor o igual a la suma de sus radios entonces es que hay un choque, y se realiza todo el siguiente procedimiento para determina las nuevas velocidades de los discos despues del choque: La norma de esta distancia d es:</p> \\[ \\|d\\| = \\sqrt{\\Delta{x}^2 + \\Delta{y}^2} \\] <p>Si la distancia d, entre ellos es menor o igual a la suma de sus radios, entonces: Se normaliza el vector d, para tener un vector unitario perpendicular \\(d_{n}\\), a la superficie de choque entre discos:</p> \\[ d_{n} = d/(\\|d\\|) \\] <p>Se determina el vector unitario tangencial \\(t_{n}\\), a la superficie de choque entre los discos, como ya se tenia normalizado al vector perpendicular \\(d_{n}\\) entonces:</p> \\[ t_{n} = (-\\Delta{y},\\Delta{x}) / \\sqrt{\\Delta{x}^2 + \\Delta{y}^2}. \\] <p>Ahora se proyectan las velocidades en los vectores unitarios perpendiculares y tangenciales:</p> \\[ v_{An1} = v_{A} d_{n} \\] \\[ v_{At1} = v_{A} t_{n} = v_{At2} \\] \\[ v_{Bn1} = v_{B} d_{n} \\] \\[ v_{Bt1} = v_{B} t_{n} = v_{At2} \\] <p>Debido a que la velocidad tangencial es exactamente solo se calcular\u00e1n la nueva velocidad perpendicular, las nuevas velocidades perpendiculares a la superficie de choque unidimensional ser\u00edan:</p> \\[ v_{An2} = (v_{An1} (m_{A} - m_{B}) + 2m_{B}v_{Bn1}) / (m_{A} + m_{B}) \\] \\[ v_{Bn2} = (v_{Bn1} (m_{B} - m_{A}) + 2m_{A}v_{An1}) / (m_{A} + m_{B}) \\] <p>Estas ser\u00edan las componentes normales del vector velocidad tras la colisi\u00f3n de ambos cuerpos, para hacerlos de nuevo como vectores se toma multiplican por el vector correspondiente que les da su direcci\u00f3n:</p> \\[ v_{An2} = v_{An2} d_{n} \\] \\[ v_{At2} = v_{At2} t_{t} \\] \\[ v_{Bn2} = v_{Bn2} d_{n} \\] \\[ v_{Bt2} = v_{Bt2} t_{t} \\] <p>Finalmente, las nuevas velocidades tras la colisi\u00f3n en el sistema de coordenadas original vendrian dadas por:</p> \\[ v_{A2} = v_{An2} + v_{At2} \\] \\[ v_{B2} = v_{Bn2} + v_{Bt2} \\] <p>Adem\u00e1s esta funci\u00f3n mueve ligeramente a los discos para que no se queden pegados en la simulaci\u00f3n. Para esto, mueve al disco A una distancia d_{m} dada por:</p> \\[ d_{m} = d_{n} (rad_{1} + rad_{1} - \\|d\\|) / 2 \\] <p>Y mueve al disco B en la direcci\u00f3n opuesta a A:</p> \\[ d_{m} = -d_{n} (rad_{1} + rad_{1} - \\|d\\|) / 2 \\] <p>Parameters:</p> Name Type Description Default <code>part1</code> <code>Particula</code> <p>El disco A del choque</p> required <code>part2</code> <code>Particula</code> <p>El disco B del choque</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def choque_elastico(part1, part2):\n    '''\n    Esta funci\u00f3n determina las nuevas velocidades de los discos A y B, si dos de ellos chocan entre s\u00ed.\n    Se tiene la distancia d entre los discos: C_A - C_B, y esta es menor o igual a la suma de sus radios\n    entonces es que hay un choque, y se realiza todo el siguiente procedimiento para determina las nuevas\n    velocidades de los discos despues del choque:\n    La norma de esta distancia d es:\n\n    $$\n    \\|d\\| = \\sqrt{\\Delta{x}^2 + \\Delta{y}^2}\n    $$\n\n    Si la distancia d, entre ellos es menor o igual a la suma de sus radios, entonces:\n    Se normaliza el vector d, para tener un vector unitario perpendicular $d_{n}$, a la superficie\n    de choque entre discos:\n\n    $$\n    d_{n} = d/(\\|d\\|)\n    $$\n\n    Se determina el vector unitario tangencial $t_{n}$, a la superficie de choque entre los discos,\n    como ya se tenia normalizado al vector perpendicular $d_{n}$ entonces:\n\n    $$\n    t_{n} = (-\\Delta{y},\\Delta{x}) / \\sqrt{\\Delta{x}^2 + \\Delta{y}^2}.\n    $$\n\n    Ahora se proyectan las velocidades en los vectores unitarios perpendiculares y tangenciales:\n\n    $$\n    v_{An1} = v_{A} d_{n}\n    $$\n\n    $$\n    v_{At1} = v_{A} t_{n} = v_{At2}\n    $$\n\n    $$\n    v_{Bn1} = v_{B} d_{n}\n    $$\n\n\n    $$\n    v_{Bt1} = v_{B} t_{n} = v_{At2}\n    $$\n\n    Debido a que la velocidad tangencial es exactamente solo se calcular\u00e1n la nueva velocidad perpendicular,\n    las nuevas velocidades perpendiculares a la superficie de choque unidimensional ser\u00edan:\n\n    $$\n    v_{An2} = (v_{An1} (m_{A} - m_{B}) + 2m_{B}v_{Bn1}) / (m_{A} + m_{B})\n    $$\n\n    $$\n    v_{Bn2} = (v_{Bn1} (m_{B} - m_{A}) + 2m_{A}v_{An1}) / (m_{A} + m_{B})\n    $$\n\n\n    Estas ser\u00edan las componentes normales del vector velocidad tras la colisi\u00f3n de ambos cuerpos,\n    para hacerlos de nuevo como vectores se toma multiplican por el vector correspondiente que les da su direcci\u00f3n:\n\n    $$\n    v_{An2} = v_{An2} d_{n}\n    $$\n\n\n    $$\n    v_{At2} = v_{At2} t_{t}\n    $$\n\n    $$\n    v_{Bn2} = v_{Bn2} d_{n}\n    $$\n\n    $$\n    v_{Bt2} = v_{Bt2} t_{t}\n    $$\n\n    Finalmente, las nuevas velocidades tras la colisi\u00f3n en el sistema de coordenadas original vendrian dadas por:\n\n    $$\n    v_{A2} = v_{An2} + v_{At2}\n    $$\n\n    $$\n    v_{B2} = v_{Bn2} + v_{Bt2}\n    $$\n\n    Adem\u00e1s esta funci\u00f3n mueve ligeramente a los discos para que no se queden pegados en la simulaci\u00f3n.\n    Para esto, mueve al disco A una distancia d_{m} dada por:\n\n    $$\n    d_{m} = d_{n} (rad_{1} + rad_{1} - \\|d\\|) / 2\n    $$\n\n    Y mueve al disco B en la direcci\u00f3n opuesta a A:\n\n    $$\n    d_{m} = -d_{n} (rad_{1} + rad_{1} - \\|d\\|) / 2\n    $$\n\n    Args:\n        part1 (Particula): El disco A del choque\n        part2 (Particula): El disco B del choque\n\n    '''\n    delta_pos = [part1.pos[0] - part2.pos[0], part1.pos[1] - part2.pos[1]]\n    dist = np.linalg.norm(delta_pos)\n    if dist &lt;= (part1.rad + part2.rad):\n        # Normalizaci\u00f3n del vector de diferencia de posici\u00f3n\n        delta_pos = [delta_pos[0] / dist, delta_pos[1] / dist]\n\n        # Vector unitario tangencial\n        delta_tan = [-delta_pos[1], delta_pos[0]]\n\n        # Proyecciones de velocidad\n        v1n = part1.v[0] * delta_pos[0] + part1.v[1] * delta_pos[1]\n        v1t = part1.v[0] * delta_tan[0] + part1.v[1] * delta_tan[1]\n        v2n = part2.v[0] * delta_pos[0] + part2.v[1] * delta_pos[1]\n        v2t = part2.v[0] * delta_tan[0] + part2.v[1] * delta_tan[1]\n\n        # Nuevas velocidades normales usando colisi\u00f3n el\u00e1stica unidimensional\n        v1n_prima = (v1n * (part1.masa - part2.masa) + 2 * part2.masa * v2n) / (part1.masa + part2.masa)\n        v2n_prima = (v2n * (part2.masa - part1.masa) + 2 * part1.masa * v1n) / (part2.masa + part1.masa)\n\n        # Conversi\u00f3n a vectores\n        v1n_prima_vec = [v1n_prima * delta_pos[0], v1n_prima * delta_pos[1]]\n        v1t_vec = [v1t * delta_tan[0], v1t * delta_tan[1]]\n        v2n_prima_vec = [v2n_prima * delta_pos[0], v2n_prima * delta_pos[1]]\n        v2t_vec = [v2t * delta_tan[0], v2t * delta_tan[1]]\n\n        # Nuevas velocidades\n        part1.v = [v1n_prima_vec[0] + v1t_vec[0], v1n_prima_vec[1] + v1t_vec[1]]\n        part2.v = [v2n_prima_vec[0] + v2t_vec[0], v2n_prima_vec[1] + v2t_vec[1]]\n\n        # Mover ligeramente las part\u00edculas para evitar que se queden pegadas\n        translape = part1.rad + part2.rad - dist\n        mover = translape / 2.0\n        part1.pos[0] += delta_pos[0] * mover\n        part1.pos[1] += delta_pos[1] * mover\n        part2.pos[0] -= delta_pos[0] * mover\n        part2.pos[1] -= delta_pos[1] * mover\n</code></pre>"},{"location":"reference/#discos.proyecto.generar_densidad_probabilidad","title":"<code>generar_densidad_probabilidad(posiciones_x)</code>","text":"<p>Esta funci\u00f3n plotea la distribucion de la densidad de probabilidad de las posiciones en x y plotea un histograma de las posiciones en el eje x.</p> <p>Parameters:</p> Name Type Description Default <code>posiciones_x</code> <code>list</code> <p>Primer argumento (una lista con el valor de las posiciones en x)</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def generar_densidad_probabilidad(posiciones_x):\n    '''Esta funci\u00f3n plotea la distribucion de la densidad de probabilidad de las posiciones en x y plotea un histograma de las posiciones en el eje x.\n\n    Args:\n        posiciones_x (list):  Primer argumento (una lista con el valor de las posiciones en x)\n\n    ''' \n    plt.figure(figsize=(12, 6))\n\n    # Subplot 1: Distribuci\u00f3n de Densidad de Probabilidad\n    plt.subplot(1, 2, 1)\n    sns.kdeplot(posiciones_x, bw_adjust=0.5, fill=True)\n    plt.title('Distribuci\u00f3n de Densidad de Probabilidad de las Posiciones en x')\n    plt.xlabel('Posici\u00f3n en x')\n    plt.ylabel('Densidad de Probabilidad')\n\n    # Subplot 2: Histograma de las Posiciones en x\n    plt.subplot(1, 2, 2)\n    plt.hist(posiciones_x, bins=100, alpha=0.6, color='g', edgecolor='black')\n    plt.title('Histograma de las Posiciones en x')\n    plt.xlabel('Posici\u00f3n en x')\n    plt.ylabel('Frecuencia')\n\n    plt.tight_layout()\n    plt.show()\n</code></pre>"},{"location":"reference/#discos.proyecto.inicializar_particulas","title":"<code>inicializar_particulas(posiciones, radios, velocidades, angulos, colores)</code>","text":"<p>Esta funci\u00f3n inicializa los atritibutos: posiciones, radios, velocidades, \u00e1ngulos y colores, de los discos.</p> <p>Parameters:</p> Name Type Description Default <code>posiciones</code> <code>list</code> <p>Lista de las posiciones de cada disco</p> required <code>radios</code> <code>list</code> <p>Lista de los radios de cada disco</p> required <code>velocidades</code> <code>list</code> <p>Lista de las velocidades de cada disco</p> required <code>angulos</code> <code>list</code> <p>Lista de los \u00e1ngulos de cada disco</p> required <code>colores</code> <code>list</code> <p>Lista de los colores de cada disco</p> required <p>Returns:</p> Name Type Description <code>particulas</code> <code>list</code> <p>Los atritibutos: posiciones, radios, masas (se defini\u00f3 una masa unitaria), velocidades, angulos y colores, de los discos</p> Source code in <code>discos/proyecto.py</code> <pre><code>def inicializar_particulas(posiciones, radios, velocidades, angulos, colores):\n    '''Esta funci\u00f3n inicializa los atritibutos: posiciones, radios, velocidades, \u00e1ngulos y colores, de los discos.\n\n    Args:\n        posiciones (list): Lista de las posiciones de cada disco\n        radios (list): Lista de los radios de cada disco\n        velocidades (list): Lista de las velocidades de cada disco\n        angulos (list): Lista de los \u00e1ngulos de cada disco\n        colores (list): Lista de los colores de cada disco\n\n    Returns:\n        particulas (list): Los atritibutos: posiciones, radios, masas (se defini\u00f3 una masa unitaria), velocidades, angulos y colores, de los discos\n    '''\n    particulas = []\n    for i in range(len(posiciones)):\n        pos = posiciones[i]\n        radio = radios[i]\n        rapidez = velocidades[i]\n        ang = angulos[i]\n        color = colores[i % len(colores)]\n        masa = 1  # Asumimos masa unitaria para simplicidad\n        particulas.append(Particula(pos, radio, masa, rapidez, ang, color))\n    return particulas\n</code></pre>"},{"location":"reference/#discos.proyecto.rebotar_pared","title":"<code>rebotar_pared(particula, size)</code>","text":"<p>Esta funci\u00f3n describe los choques de las part\u00edculas con la pared. Se asegura de que las part\u00edculas reboten el\u00e1sticamente contra las paredes de la caja. Verifica cada componente de la posici\u00f3n respecto a los l\u00edmites de la caja y ajusta tanto la velocidad como la posici\u00f3n de la part\u00edcula en caso de una colisi\u00f3n con una pared.</p> <p>La condici\u00f3n de si la posici\u00f5n del disco en x es mayor a la longitud de una de las caras de la caja menos el radio del disco verifica si la posici\u00f3n en x de la part\u00edcula + su radio excede el l\u00edmite derecho de la caja. Si ese es el caso, entonces choca con la pared derecha y entonces</p> \\[ v_{x} = -v{x} \\] <p>Y</p> \\[ x_{0} = size[0] - r \\] <p>Donde v es la velocidad del disco, size[0] la longitud de la caja en x y r el radio del disco. Esta funci\u00f3n invierte la componente x de la velocidad (simulando un rebote el\u00e1stico) y ajusta la posici\u00f3n x para que la part\u00edcula no se salga de la caja. </p> <p>Esta misma din\u00e1mica cumple con todos los condicionales, cada uno analizando el choque con una pared en espec\u00edfico.</p> <p>Parameters:</p> Name Type Description Default <code>part\u00edcula</code> <code>class</code> <p>representa a una part\u00edcula individual dentro de la simulaci\u00f3n. Se utiliza para poder modificar las propiedades de una part\u00edcula (en este caso su posici\u00f3n y velocidad) al detectar colisiones con las paredes de la caja.</p> required <code>size</code> <code>tuple</code> <p>Tupla de dos elementos \u00b4(ancho, alto)\u00b4 que representa las dimensiones de la caja en la que se est\u00e1n moviendo las part\u00edculas. (\u00b4size[0]\u00b4 es el ancho de la caja y \u00b4size[1]\u00b4 es la altura de la caja, en este caso nuestra caja es de medida 1x1). Se utiliza para delimitar las paredes de la caja y as\u00ed poder verificar las colisiones con \u00e9sta.</p> required Source code in <code>discos/proyecto.py</code> <pre><code>def rebotar_pared(particula, size):\n    '''Esta funci\u00f3n describe los choques de las part\u00edculas con la pared.\n       Se asegura de que las part\u00edculas reboten el\u00e1sticamente contra las paredes de la caja.\n       Verifica cada componente de la posici\u00f3n respecto a los l\u00edmites de la caja y\n       ajusta tanto la velocidad como la posici\u00f3n de la part\u00edcula en caso de una colisi\u00f3n con una pared.\n\n       La condici\u00f3n de si la posici\u00f5n del disco en x es mayor a la longitud de una de las caras de la caja menos el radio\n       del disco verifica si la posici\u00f3n en x de la part\u00edcula + su radio\n       excede el l\u00edmite derecho de la caja. Si ese es el caso, entonces choca con la pared derecha y entonces\n\n       $$\n       v_{x} = -v{x}\n       $$\n\n       Y\n\n       $$\n       x_{0} = size[0] - r\n       $$\n\n       Donde v es la velocidad del disco, size[0] la longitud de la caja en x\n       y r el radio del disco.\n       Esta funci\u00f3n invierte la componente x de la velocidad (simulando un rebote el\u00e1stico) y\n       ajusta la posici\u00f3n x para que la part\u00edcula no se salga de la caja. \n\n       Esta misma din\u00e1mica cumple con todos los condicionales, cada uno analizando el choque con una pared en espec\u00edfico.\n\n       Args: \n           part\u00edcula (class): representa a una part\u00edcula individual dentro de la simulaci\u00f3n. Se utiliza para poder modificar las propiedades de una part\u00edcula (en este caso su posici\u00f3n y velocidad) al detectar colisiones con las paredes de la caja.\n           size (tuple): Tupla de dos elementos \u00b4(ancho, alto)\u00b4 que representa las dimensiones de la caja en la que se est\u00e1n moviendo las part\u00edculas. (\u00b4size[0]\u00b4 es el ancho de la caja y \u00b4size[1]\u00b4 es la altura de la caja, en este caso nuestra caja es de medida 1x1). Se utiliza para delimitar las paredes de la caja y as\u00ed poder verificar las colisiones con \u00e9sta.\n    '''\n    if particula.pos[0] &gt;= size[0] - particula.rad:\n        particula.v[0] = -particula.v[0]\n        particula.pos[0] = size[0] - particula.rad\n    elif particula.pos[0] &lt;= particula.rad:\n        particula.v[0] = -particula.v[0]\n        particula.pos[0] = particula.rad\n    if particula.pos[1] &gt;= size[1] - particula.rad:\n        particula.v[1] = -particula.v[1]\n        particula.pos[1] = size[1] - particula.rad\n    elif particula.pos[1] &lt;= particula.rad:\n        particula.v[1] = -particula.v[1]\n        particula.pos[1] = particula.rad\n</code></pre>"}]}